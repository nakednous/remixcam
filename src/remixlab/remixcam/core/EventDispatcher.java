package remixlab.remixcam.core;

import remixlab.remixcam.core.AbstractScene.*;
import remixlab.remixcam.event.DLEvent;
import remixlab.remixcam.event.DLKeyEvent;
import remixlab.remixcam.event.DLMouseEvent;
import remixlab.remixcam.event.HIDeviceEvent;
import remixlab.remixcam.geom.Point;

/**
 * This class provides low level java.awt.* based input event handling.
 * <p>
 * In order to handle input events generated by Processing with proscene, this object needs
 * to be registered  at the PApplet (which is done through
 * {@link remixlab.proscene.Scene#enableKeyboardHandling()} and
 * {@link remixlab.proscene.Scene#enableMouseHandling()}). Input events (keyboard and mouse)
 * generated via Processing will then be directed to {@link #DLDLKeyEvent(DLDLKeyEvent)} and to
 * {@link #handleMouseEvent(DLMouseEvent)}.  
 */
//TODO should be AbstractScene inner class
public class EventDispatcher implements Constants {
	protected AbstractScene scene;
	public DeviceAction camMouseAction;
	protected boolean keyHandled;
  //Z O O M _ O N _ R E G I O N
	public Point fCorner;// also used for SCREEN_ROTATE
	public Point lCorner;
	
	public EventDispatcher(AbstractScene s) {
		scene = s;
		camMouseAction = DeviceAction.NO_DEVICE_ACTION;
		keyHandled = false;
		fCorner = new Point();
		lCorner = new Point();
	}
	
	//TODO generalize me
	// /**
	public void handle(DLEvent e) {		
		if( e instanceof DLKeyEvent ) {
			handleKeyEvent((DLKeyEvent) e);
		}
		if( e instanceof HIDeviceEvent ) {
			//handleMouseEvent((DLMouseEvent) e); 
		}
	}
	//*/
	
	// 1. KeyEvents
	
	/**
	 * Keyboard event handler.
	 * 
	 * @see remixlab.proscene.Scene#keyboardIsHandled()
	 * @see remixlab.proscene.Scene#enableKeyboardHandling(boolean)
	 */
	public boolean handleKeyEvent(DLKeyEvent e) {
		boolean handled = false;
		if (scene.currentCameraProfile() == null)
			return handled;
		
		handled = keyCharCameraKeyboardAction(e);
		if (!handled)
			handled = keyCharKeyboardAction(e);		
		if (!handled)
			handled = keyCodedCameraKeyboardAction(e);
		if (!handled)
			keyCodedKeyboardAction(e);
		
		return handled;
	}
	// */
	
	/**
	 * Implementation of the key typed event used to handle character shortcuts.
	 * <p>
	 * The handler queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding there first. If nothing is found,
	 * the handler look for it in the Scene then.
	 * 
	 * @see #keyCharCameraKeyboardAction(DLKeyEvent)
	 * @see #keyCharKeyboardAction(DLKeyEvent)
	 */
	public void keyChar(DLKeyEvent e) {
		boolean handled = false;		
		if (scene.currentCameraProfile() != null)
			handled = keyCharCameraKeyboardAction(e);
		if (!handled)
			handled = keyCharKeyboardAction(e);
		keyHandled = handled;
	}
	
	/**
	 * Implementation of the key released event used to handle complex shortcuts, i.e.,
	 * shortcuts involving a keycode plus a modifier mask.
	 * <p>
	 * The handler looks for a possible binding in the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} first.
	 * If the {@link remixlab.proscene.Scene#currentCameraProfile()} doesn't bind an action,
	 * the handler searches for it in the Scene.
	 * 
	 * @see #keyCodedCameraKeyboardAction(DLKeyEvent)
	 * @see #keyCodedKeyboardAction(DLKeyEvent)
	 */
	public void keyCoded(DLKeyEvent e) {
		if(keyHandled)
			return;
		boolean handled = false;
		if (scene.currentCameraProfile() != null)
			handled = keyCodedCameraKeyboardAction(e);
		if (!handled)
			keyCodedKeyboardAction(e);
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the character associated with the key from the DLKeyEvent
	 * and then queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyCharCameraKeyboardAction(DLKeyEvent e) {
		CameraKeyboardAction kba = null;
		kba = scene.currentCameraProfile().shortcut( e.getKey() );
		if (kba == null)
			return false;
		else {
			scene.handleCameraKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the character associated with the key from the DLKeyEvent
	 * and then queries the Scene to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyCharKeyboardAction(DLKeyEvent e) {
		if (!e.isAltDown() /**&& !e.isAltGraphDown()*/ && !e.isControlDown()	&& !e.isShiftDown()) {
			Integer path = scene.path(e.getKey());
			if (path != null) {
				scene.pinhole().playPath(path);
				return true;
			}
		}
		
		KeyboardAction kba = null;
		kba = scene.shortcut(e.getKey());
		if (kba == null)
			return false;
		else {
			scene.handleKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the key combination (keycode +  modifier mask) associated with
	 * the DLKeyEvent and then queries the {@link remixlab.proscene.Scene#currentCameraProfile()}
	 * to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyCodedCameraKeyboardAction(DLKeyEvent e) {
		CameraKeyboardAction kba = null;
		kba = scene.currentCameraProfile().shortcut( e.getModifiers(), e.getKeyCode() );
		if (kba == null)
			return false;
		else {
			scene.handleCameraKeyboardAction(kba);
			return true;
		}
	}
	
	/**
	 * Internal use.
	 * <p>
	 * This method extracts the key combination (keycode + modifier mask) associated with
	 * the DLKeyEvent and then queries the Scene to see if there's a binding for it.
	 * 
	 * @return true if a binding was found 
	 */
	protected boolean keyCodedKeyboardAction(DLKeyEvent e) {
		// 1. Key-frames
		// 1.1. Need to add a key-frame?
		if (((scene.addKeyFrameKeyboardModifier == ALT) && (e.isAltDown()))
	   /**|| ((scene.addKeyFrameKeyboardModifier == ALT_GRAPH) && (e.isAltGraphDown()))*/
		 || ((scene.addKeyFrameKeyboardModifier == META) && (e.isMetaDown()))
		 || ((scene.addKeyFrameKeyboardModifier == CTRL) && (e.isControlDown()))
		 || ((scene.addKeyFrameKeyboardModifier == SHIFT) && (e.isShiftDown()))) {
			Integer path = scene.path(e.getKeyCode());
			if (path != null) {
				scene.pinhole().addKeyFrameToPath(path);
				return true;
			}
		}
  	// 1.2. Need to delete a key-frame?
		if (((scene.deleteKeyFrameKeyboardModifier == ALT) && (e.isAltDown()))
		 /**|| ((scene.deleteKeyFrameKeyboardModifier == ALT_GRAPH) && (e.isAltGraphDown()))*/
		 || ((scene.deleteKeyFrameKeyboardModifier == META) && (e.isMetaDown()))
		 || ((scene.deleteKeyFrameKeyboardModifier == CTRL) && (e.isControlDown()))
		 || ((scene.deleteKeyFrameKeyboardModifier == SHIFT) && (e.isShiftDown()))) {
			Integer path = scene.path(e.getKeyCode());
			if (path != null) {
				scene.pinhole().deletePath(path);
				return true;
			}
		}		
		// 2. General actions
		KeyboardAction kba = null;
		kba = scene.shortcut( e.getModifiers(), e.getKeyCode() );
		if (kba == null)
			return false;
		else {
			scene.handleKeyboardAction(kba);
			return true;
		}
	}
	
	// 2. Mouse Events
	
	/**
	 * Mouse event handler.
	 * 
	 * @see remixlab.proscene.Scene#mouseIsHandled()
	 * @see remixlab.proscene.Scene#enableMouseHandling(boolean)
	 */
	public void handleMouseEvent(DLMouseEvent e) {
		scene.mouseX = e.getX();
		scene.mouseY = e.getY();
		/**
		switch (e.getAction() ) {
		case DLMouseEvent.CLICK:
			mouseClicked(e);
			break;
		case DLMouseEvent.DRAG:
			mouseDragged(e);
			break;
		case DLMouseEvent.MOVE:
			mouseMoved(e);
			break;
		case DLMouseEvent.PRESS:
			mousePressed(e);
			break;
		case DLMouseEvent.RELEASE:
			mouseReleased(e);
			break;
		case DLMouseEvent.WHEEL:
		  //TODO 1-DOF -> wheel			
			//mouseWheelMoved(e);
		}		
		*/
	}
	
  /**
   * The action generated when the user clicks the mouse is handled by the
   * {@link remixlab.proscene.Scene#deviceGrabber()} (if any). Otherwise
   * looks in the {@link remixlab.proscene.Scene#currentCameraProfile()} to see if there's
   * a binding for this click event, taking into account the button, the modifier mask, and
   * the number of clicks.
   */
	protected void mouseClicked(DLMouseEvent event) {		
		if (scene.deviceGrabber() != null)
			scene.deviceGrabber().buttonClicked(/**event.getPoint(),*/ event.getButton(), event.getClickCount());
		else {
			ClickAction ca = scene.currentCameraProfile().clickBinding(event.getModifiers(), event.getButton(), event.getClickCount());
			if (ca != null)
				scene.handleClickAction(ca);
		}
	}
	
	/**
	 * {@link remixlab.proscene.Scene#setDeviceGrabber(MouseGrabbable)} to the MouseGrabber that grabs the
	 * mouse (or to {@code null} if none of them grab it).
	 */
	public void mouseMoved(DLMouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		scene.setDeviceGrabber(null);
		if( scene.isTrackingDevice() )
			for (DeviceGrabbable mg : scene.deviceGrabberPool()) {
				mg.checkIfGrabsCursor(event.getX(), event.getY());
				if (mg.grabsCursor())
					scene.setDeviceGrabber(mg);
			}
	}
	
	/**
	 * The action generated when the user clicks and drags the mouse is handled by the
	 * {@link remixlab.proscene.Scene#deviceGrabber()} (if any), or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}
	 * (if @link remixlab.proscene.Scene#interactiveFrameIsDrawn()), or the
	 * {@link remixlab.proscene.Scene#pinhole()} (checks are performed in that order).
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #awtMouseDragged(DLMouseEvent)
	 * @see #awtMouseReleased(DLMouseEvent)
	 * @see #mouseWheelMoved(MouseWheelEvent)
	 */
	public void mousePressed(DLMouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.deviceGrabber() != null) {
			if (scene.deviceGrabberIsAnIFrame) { //covers also the case when mouseGrabberIsADrivableFrame
				InteractiveFrame iFrame = (InteractiveFrame) scene.deviceGrabber();
				iFrame.beginAction(scene.currentCameraProfile().frameMouseAction(e));
				iFrame.beginInteraction(new Point(event.getX(), event.getY()));
			} else
				scene.deviceGrabber().beginInteraction(new Point(event.getX(), event.getY()));
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			//scene.interactiveFrame().startAction(scene.currentCameraProfile().frameMouseAction(e), scene.drawIsConstrained());
			scene.interactiveFrame().beginAction(scene.currentCameraProfile().frameMouseAction(e.getModifiers(), e.getButton()));
			scene.interactiveFrame().beginInteraction(new Point(event.getX(), event.getY()));
			return;
		}
		//camMouseAction = scene.currentCameraProfile().cameraMouseAction(e);
		camMouseAction = scene.currentCameraProfile().cameraMouseAction(e.getModifiers(), e.getButton());
		if (camMouseAction == DeviceAction.ZOOM_ON_REGION) {
			fCorner.set(event.getX(), event.getY());
			lCorner.set(event.getX(), event.getY());
		}
		if (camMouseAction == DeviceAction.SCREEN_ROTATE)
			fCorner.set(event.getX(), event.getY());
		scene.pinhole().frame().beginAction(camMouseAction);
		scene.pinhole().frame().beginInteraction(new Point(event.getX(), event.getY()));
	}

	/**
	 * The mouse dragged event is sent to the {@link remixlab.proscene.Scene#deviceGrabber()}
	 * or the {@link remixlab.proscene.Scene#interactiveFrame()}, or to the
	 * {@link remixlab.proscene.Scene#pinhole()}, according to the action started at
	 * {@link #awtMousePressed(DLMouseEvent)}.
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #awtMousePressed(DLMouseEvent)
	 * @see #awtMouseReleased(DLMouseEvent)
	 */
	public void mouseDragged(DLMouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.deviceGrabber() != null) {
			scene.deviceGrabber().checkIfGrabsCursor(event.getX(), event.getY());
			if (scene.deviceGrabber().grabsCursor())
				if (scene.deviceGrabberIsAnIFrame) //covers also the case when mouseGrabberIsADrivableFrame
					((InteractiveFrame) scene.deviceGrabber()).performInteraction(new Point(event.getX(), event.getY()));	
				else
					scene.deviceGrabber().performInteraction(new Point(event.getX(), event.getY()));
			else
				scene.setDeviceGrabber(null);
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
		  scene.interactiveFrame().performInteraction(new Point(event.getX(), event.getY()));
			return;
		}
		if (camMouseAction == DeviceAction.ZOOM_ON_REGION)
			lCorner.set(event.getX(), event.getY());
		else {
			if (camMouseAction == DeviceAction.SCREEN_ROTATE)
				fCorner.set(event.getX(), event.getY());
			scene.pinhole().frame().performInteraction(new Point(event.getX(), event.getY()));
		}
	}
	
	/**
	 * The mouse released event (which ends a mouse action) is sent to the
	 * {@link remixlab.proscene.Scene#deviceGrabber()} or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}, or to the
	 * {@link remixlab.proscene.Scene#pinhole()}, according to the action started at
	 * {@link #mousePressed(DLMouseEvent)}.
	 * <p>
	 * Mouse displacements are interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse bindings.
	 * 
	 * @see #mousePressed(DLMouseEvent)
	 * @see #mouseDragged(DLMouseEvent)
	 */
	public void mouseReleased(DLMouseEvent e) {
		Point event = new Point((e.getX() - scene.upperLeftCorner.getX()), (e.getY() - scene.upperLeftCorner.getY()));
		if (scene.deviceGrabber() != null) {
			if (scene.deviceGrabberIsAnIFrame) //covers also the case when mouseGrabberIsADrivableFrame
				((InteractiveFrame) scene.deviceGrabber()).endInteraction(new Point(event.getX(), event.getY()));
			else
				scene.deviceGrabber().endInteraction(new Point(event.getX(), event.getY()));
			scene.deviceGrabber().checkIfGrabsCursor(event.getX(), event.getY());
			if (!(scene.deviceGrabber().grabsCursor()))
				scene.setDeviceGrabber(null);
			// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			scene.interactiveFrame().endInteraction(new Point(event.getX(), event.getY()));
			// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
			return;
		}

		if ((camMouseAction == DeviceAction.ZOOM_ON_REGION)
				|| (camMouseAction == DeviceAction.SCREEN_ROTATE)
				|| (camMouseAction == DeviceAction.SCREEN_TRANSLATE))
			lCorner.set(event.getX(), event.getY());
		scene.pinhole().frame().endInteraction(new Point(event.getX(), event.getY()));
		camMouseAction = DeviceAction.NO_DEVICE_ACTION;
		// iFrameMouseAction = MouseAction.NO_MOUSE_ACTION;
	}
	
	/**
	 * The action generated when the user start rotating the mouse wheel is handled by the
	 * {@link remixlab.proscene.Scene#deviceGrabber()} (if any), or the
	 * {@link remixlab.proscene.Scene#interactiveFrame()}
	 * (if @link remixlab.proscene.Scene#interactiveFrameIsDrawn()), or the
	 * {@link remixlab.proscene.Scene#pinhole()} (checks are performed in that order).
	 * <p>
	 * Mouse wheel rotation is interpreted according to the
	 * {@link remixlab.proscene.Scene#currentCameraProfile()} mouse wheel bindings.
	 * 
	 * @see #mousePressed(DLMouseEvent)
	 */
	/**
	public void mouseWheelMoved(DLMouseEvent event) {
		//if(!scene.mouseIsHandled())
			//return;
		if (scene.deviceGrabber() != null) {
			if (scene.deviceGrabberIsAnIFrame) { //covers also the case when mouseGrabberIsADrivableFrame
				InteractiveFrame iFrame = (InteractiveFrame) scene.deviceGrabber();
				iFrame.startAction(scene.currentCameraProfile().frameWheelMouseAction(event));
				iFrame.wheelMoved(event.getAmount());				
			} else
				scene.deviceGrabber().wheelMoved(event.getAmount());
			return;
		}
		if (scene.interactiveFrameIsDrawn()) {
			scene.interactiveFrame().startAction(scene.currentCameraProfile().frameWheelMouseAction(event.getModifiers()));
			scene.interactiveFrame().wheelMoved(event.getAmount());
			return;
		}
		//scene.pinhole().frame().startAction(scene.currentCameraProfile().cameraWheelMouseAction(event), scene.drawIsConstrained());
		scene.pinhole().frame().startAction(scene.currentCameraProfile().cameraWheelMouseAction(event.getModifiers()));
		scene.pinhole().frame().wheelMoved(event.getAmount());	  
	}
	*/
}

